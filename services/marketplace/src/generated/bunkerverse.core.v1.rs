// This file is @generated by prost-build.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BunkerClassProto {
    BunkerClassUnspecified = 0,
    Explorer = 1,
    Pathfinder = 2,
    Cybermancer = 3,
    Vanguard = 4,
    Enforcer = 5,
    Scavenger = 6,
    Stalker = 7,
    Disruptor = 8,
    Codebreaker = 9,
    Overlord = 10,
    Breacher = 11,
    Reclaimer = 12,
}
impl BunkerClassProto {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            BunkerClassProto::BunkerClassUnspecified => "BUNKER_CLASS_UNSPECIFIED",
            BunkerClassProto::Explorer => "EXPLORER",
            BunkerClassProto::Pathfinder => "PATHFINDER",
            BunkerClassProto::Cybermancer => "CYBERMANCER",
            BunkerClassProto::Vanguard => "VANGUARD",
            BunkerClassProto::Enforcer => "ENFORCER",
            BunkerClassProto::Scavenger => "SCAVENGER",
            BunkerClassProto::Stalker => "STALKER",
            BunkerClassProto::Disruptor => "DISRUPTOR",
            BunkerClassProto::Codebreaker => "CODEBREAKER",
            BunkerClassProto::Overlord => "OVERLORD",
            BunkerClassProto::Breacher => "BREACHER",
            BunkerClassProto::Reclaimer => "RECLAIMER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BUNKER_CLASS_UNSPECIFIED" => Some(Self::BunkerClassUnspecified),
            "EXPLORER" => Some(Self::Explorer),
            "PATHFINDER" => Some(Self::Pathfinder),
            "CYBERMANCER" => Some(Self::Cybermancer),
            "VANGUARD" => Some(Self::Vanguard),
            "ENFORCER" => Some(Self::Enforcer),
            "SCAVENGER" => Some(Self::Scavenger),
            "STALKER" => Some(Self::Stalker),
            "DISRUPTOR" => Some(Self::Disruptor),
            "CODEBREAKER" => Some(Self::Codebreaker),
            "OVERLORD" => Some(Self::Overlord),
            "BREACHER" => Some(Self::Breacher),
            "RECLAIMER" => Some(Self::Reclaimer),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ClassAffiliationProto {
    ClassAffiliationUnspecified = 0,
    Loyal = 1,
    Corrupt = 2,
    Neutral = 3,
}
impl ClassAffiliationProto {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ClassAffiliationProto::ClassAffiliationUnspecified => {
                "CLASS_AFFILIATION_UNSPECIFIED"
            }
            ClassAffiliationProto::Loyal => "LOYAL",
            ClassAffiliationProto::Corrupt => "CORRUPT",
            ClassAffiliationProto::Neutral => "NEUTRAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CLASS_AFFILIATION_UNSPECIFIED" => Some(Self::ClassAffiliationUnspecified),
            "LOYAL" => Some(Self::Loyal),
            "CORRUPT" => Some(Self::Corrupt),
            "NEUTRAL" => Some(Self::Neutral),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NexusTypeProto {
    NexusTypeUnspecified = 0,
    Home = 1,
    Community = 2,
    MiniGames = 3,
    Forum = 4,
    Marketplace = 5,
}
impl NexusTypeProto {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            NexusTypeProto::NexusTypeUnspecified => "NEXUS_TYPE_UNSPECIFIED",
            NexusTypeProto::Home => "HOME",
            NexusTypeProto::Community => "COMMUNITY",
            NexusTypeProto::MiniGames => "MINI_GAMES",
            NexusTypeProto::Forum => "FORUM",
            NexusTypeProto::Marketplace => "MARKETPLACE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NEXUS_TYPE_UNSPECIFIED" => Some(Self::NexusTypeUnspecified),
            "HOME" => Some(Self::Home),
            "COMMUNITY" => Some(Self::Community),
            "MINI_GAMES" => Some(Self::MiniGames),
            "FORUM" => Some(Self::Forum),
            "MARKETPLACE" => Some(Self::Marketplace),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ItemRarityProto {
    ItemRarityUnspecified = 0,
    Standard = 1,
    Optimized = 2,
    Advanced = 3,
    Supreme = 4,
    Echelon = 5,
    Eternal = 6,
}
impl ItemRarityProto {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ItemRarityProto::ItemRarityUnspecified => "ITEM_RARITY_UNSPECIFIED",
            ItemRarityProto::Standard => "STANDARD",
            ItemRarityProto::Optimized => "OPTIMIZED",
            ItemRarityProto::Advanced => "ADVANCED",
            ItemRarityProto::Supreme => "SUPREME",
            ItemRarityProto::Echelon => "ECHELON",
            ItemRarityProto::Eternal => "ETERNAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ITEM_RARITY_UNSPECIFIED" => Some(Self::ItemRarityUnspecified),
            "STANDARD" => Some(Self::Standard),
            "OPTIMIZED" => Some(Self::Optimized),
            "ADVANCED" => Some(Self::Advanced),
            "SUPREME" => Some(Self::Supreme),
            "ECHELON" => Some(Self::Echelon),
            "ETERNAL" => Some(Self::Eternal),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ItemConditionProto {
    ItemConditionUnspecified = 0,
    PrimeState = 1,
    NewState = 2,
    UsedState = 3,
    BrokenState = 4,
}
impl ItemConditionProto {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ItemConditionProto::ItemConditionUnspecified => "ITEM_CONDITION_UNSPECIFIED",
            ItemConditionProto::PrimeState => "PRIME_STATE",
            ItemConditionProto::NewState => "NEW_STATE",
            ItemConditionProto::UsedState => "USED_STATE",
            ItemConditionProto::BrokenState => "BROKEN_STATE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ITEM_CONDITION_UNSPECIFIED" => Some(Self::ItemConditionUnspecified),
            "PRIME_STATE" => Some(Self::PrimeState),
            "NEW_STATE" => Some(Self::NewState),
            "USED_STATE" => Some(Self::UsedState),
            "BROKEN_STATE" => Some(Self::BrokenState),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ItemTypeProto {
    ItemTypeUnspecified = 0,
    Head = 1,
    Torso = 2,
    Gear = 3,
    Accessory = 4,
    Perk = 5,
    Badge = 6,
    BunkerguardRobot = 7,
    RobotItem = 8,
    CosmeticSkin = 9,
}
impl ItemTypeProto {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ItemTypeProto::ItemTypeUnspecified => "ITEM_TYPE_UNSPECIFIED",
            ItemTypeProto::Head => "HEAD",
            ItemTypeProto::Torso => "TORSO",
            ItemTypeProto::Gear => "GEAR",
            ItemTypeProto::Accessory => "ACCESSORY",
            ItemTypeProto::Perk => "PERK",
            ItemTypeProto::Badge => "BADGE",
            ItemTypeProto::BunkerguardRobot => "BUNKERGUARD_ROBOT",
            ItemTypeProto::RobotItem => "ROBOT_ITEM",
            ItemTypeProto::CosmeticSkin => "COSMETIC_SKIN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ITEM_TYPE_UNSPECIFIED" => Some(Self::ItemTypeUnspecified),
            "HEAD" => Some(Self::Head),
            "TORSO" => Some(Self::Torso),
            "GEAR" => Some(Self::Gear),
            "ACCESSORY" => Some(Self::Accessory),
            "PERK" => Some(Self::Perk),
            "BADGE" => Some(Self::Badge),
            "BUNKERGUARD_ROBOT" => Some(Self::BunkerguardRobot),
            "ROBOT_ITEM" => Some(Self::RobotItem),
            "COSMETIC_SKIN" => Some(Self::CosmeticSkin),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StatCategoryProto {
    StatCategoryUnspecified = 0,
    Combat = 1,
    Mobility = 2,
    Survivability = 3,
    Sensors = 4,
}
impl StatCategoryProto {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            StatCategoryProto::StatCategoryUnspecified => "STAT_CATEGORY_UNSPECIFIED",
            StatCategoryProto::Combat => "COMBAT",
            StatCategoryProto::Mobility => "MOBILITY",
            StatCategoryProto::Survivability => "SURVIVABILITY",
            StatCategoryProto::Sensors => "SENSORS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STAT_CATEGORY_UNSPECIFIED" => Some(Self::StatCategoryUnspecified),
            "COMBAT" => Some(Self::Combat),
            "MOBILITY" => Some(Self::Mobility),
            "SURVIVABILITY" => Some(Self::Survivability),
            "SENSORS" => Some(Self::Sensors),
            _ => None,
        }
    }
}
/// Error codes for API responses
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ErrorCodeProto {
    ErrorCodeUnspecified = 0,
    Unknown = 1,
    NotFound = 2,
    Unauthorized = 3,
    InvalidInput = 4,
    /// For on-chain features in MVE
    FeatureDisabled = 5,
    RateLimited = 6,
    InternalError = 7,
    InsufficientBalance = 8,
    TransactionFailed = 9,
}
impl ErrorCodeProto {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ErrorCodeProto::ErrorCodeUnspecified => "ERROR_CODE_UNSPECIFIED",
            ErrorCodeProto::Unknown => "UNKNOWN",
            ErrorCodeProto::NotFound => "NOT_FOUND",
            ErrorCodeProto::Unauthorized => "UNAUTHORIZED",
            ErrorCodeProto::InvalidInput => "INVALID_INPUT",
            ErrorCodeProto::FeatureDisabled => "FEATURE_DISABLED",
            ErrorCodeProto::RateLimited => "RATE_LIMITED",
            ErrorCodeProto::InternalError => "INTERNAL_ERROR",
            ErrorCodeProto::InsufficientBalance => "INSUFFICIENT_BALANCE",
            ErrorCodeProto::TransactionFailed => "TRANSACTION_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ERROR_CODE_UNSPECIFIED" => Some(Self::ErrorCodeUnspecified),
            "UNKNOWN" => Some(Self::Unknown),
            "NOT_FOUND" => Some(Self::NotFound),
            "UNAUTHORIZED" => Some(Self::Unauthorized),
            "INVALID_INPUT" => Some(Self::InvalidInput),
            "FEATURE_DISABLED" => Some(Self::FeatureDisabled),
            "RATE_LIMITED" => Some(Self::RateLimited),
            "INTERNAL_ERROR" => Some(Self::InternalError),
            "INSUFFICIENT_BALANCE" => Some(Self::InsufficientBalance),
            "TRANSACTION_FAILED" => Some(Self::TransactionFailed),
            _ => None,
        }
    }
}
/// Transaction status for L3 chain operations
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TransactionStatusProto {
    TransactionStatusUnspecified = 0,
    Pending = 1,
    Confirmed = 2,
    Failed = 3,
    Timeout = 4,
}
impl TransactionStatusProto {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TransactionStatusProto::TransactionStatusUnspecified => {
                "TRANSACTION_STATUS_UNSPECIFIED"
            }
            TransactionStatusProto::Pending => "PENDING",
            TransactionStatusProto::Confirmed => "CONFIRMED",
            TransactionStatusProto::Failed => "FAILED",
            TransactionStatusProto::Timeout => "TIMEOUT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRANSACTION_STATUS_UNSPECIFIED" => Some(Self::TransactionStatusUnspecified),
            "PENDING" => Some(Self::Pending),
            "CONFIRMED" => Some(Self::Confirmed),
            "FAILED" => Some(Self::Failed),
            "TIMEOUT" => Some(Self::Timeout),
            _ => None,
        }
    }
}
/// Market listing status
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MarketStatusProto {
    MarketStatusUnspecified = 0,
    NotListed = 1,
    ListedForSale = 2,
    ListedForAuction = 3,
    Sold = 4,
    Cancelled = 5,
}
impl MarketStatusProto {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            MarketStatusProto::MarketStatusUnspecified => "MARKET_STATUS_UNSPECIFIED",
            MarketStatusProto::NotListed => "NOT_LISTED",
            MarketStatusProto::ListedForSale => "LISTED_FOR_SALE",
            MarketStatusProto::ListedForAuction => "LISTED_FOR_AUCTION",
            MarketStatusProto::Sold => "SOLD",
            MarketStatusProto::Cancelled => "CANCELLED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MARKET_STATUS_UNSPECIFIED" => Some(Self::MarketStatusUnspecified),
            "NOT_LISTED" => Some(Self::NotListed),
            "LISTED_FOR_SALE" => Some(Self::ListedForSale),
            "LISTED_FOR_AUCTION" => Some(Self::ListedForAuction),
            "SOLD" => Some(Self::Sold),
            "CANCELLED" => Some(Self::Cancelled),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoreStatsProto {
    /// Combat stats (4 sub-stats)
    ///
    /// Range: 0-1000
    #[prost(uint32, tag = "1")]
    pub damage: u32,
    /// Range: 0-1000
    #[prost(uint32, tag = "2")]
    pub accuracy: u32,
    /// Range: 0-1000
    #[prost(uint32, tag = "3")]
    pub critical_chance: u32,
    /// Range: 0-1000
    #[prost(uint32, tag = "4")]
    pub armor_piercing: u32,
    /// Mobility stats (4 sub-stats)
    ///
    /// Range: 0-1000
    #[prost(uint32, tag = "5")]
    pub speed: u32,
    /// Range: 0-1000
    #[prost(uint32, tag = "6")]
    pub agility: u32,
    /// Range: 0-1000
    #[prost(uint32, tag = "7")]
    pub stealth: u32,
    /// Range: 0-1000
    #[prost(uint32, tag = "8")]
    pub evasion: u32,
    /// Survivability stats (2 sub-stats)
    ///
    /// Range: 0-1000
    #[prost(uint32, tag = "9")]
    pub health: u32,
    /// Range: 0-1000
    #[prost(uint32, tag = "10")]
    pub shield: u32,
    /// Sensors stats (2 sub-stats)
    ///
    /// Range: 0-1000
    #[prost(uint32, tag = "11")]
    pub detection: u32,
    /// Range: 0-1000
    #[prost(uint32, tag = "12")]
    pub range: u32,
    /// Category averages (calculated from sub-stats)
    ///
    /// Average of damage, accuracy, critical_chance, armor_piercing
    #[prost(uint32, tag = "13")]
    pub combat_average: u32,
    /// Average of speed, agility, stealth, evasion
    #[prost(uint32, tag = "14")]
    pub mobility_average: u32,
    /// Average of health, shield
    #[prost(uint32, tag = "15")]
    pub survivability_average: u32,
    /// Average of detection, range
    #[prost(uint32, tag = "16")]
    pub sensors_average: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NftIdentifierProto {
    /// UUID v4 format: ^\[0-9a-f\]{8}-\[0-9a-f\]{4}-\[0-9a-f\]{4}-\[0-9a-f\]{4}-\[0-9a-f\]{12}$
    #[prost(string, tag = "1")]
    pub nft_id: ::prost::alloc::string::String,
    /// On-chain token ID for L3 contract
    #[prost(uint64, tag = "2")]
    pub token_id: u64,
    /// Ethereum address: ^0x\[a-fA-F0-9\]{40}$
    #[prost(string, tag = "3")]
    pub contract_address: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NftDetailsProto {
    #[prost(message, optional, tag = "1")]
    pub identifier: ::core::option::Option<NftIdentifierProto>,
    #[prost(enumeration = "ItemRarityProto", tag = "2")]
    pub item_rarity: i32,
    #[prost(enumeration = "ItemTypeProto", tag = "3")]
    pub item_type: i32,
    #[prost(message, optional, tag = "4")]
    pub base_stat_boosts: ::core::option::Option<CoreStatsProto>,
    #[prost(enumeration = "BunkerClassProto", repeated, tag = "5")]
    pub class_affinities: ::prost::alloc::vec::Vec<i32>,
    #[prost(enumeration = "ClassAffiliationProto", tag = "6")]
    pub trait_affiliation: i32,
    /// Max length: 256 chars
    #[prost(string, tag = "7")]
    pub construct_origin: ::prost::alloc::string::String,
    /// IPFS CID, format: Qm\[1-9A-HJ-NP-Za-km-z\]{44}
    #[prost(string, tag = "8")]
    pub metadata_pointer_uri: ::prost::alloc::string::String,
    /// Starting at 1
    #[prost(uint32, tag = "9")]
    pub schema_version: u32,
    /// Unix timestamp
    #[prost(int64, tag = "10")]
    pub created_timestamp: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NftMutableStateProto {
    /// Player UUID
    #[prost(string, tag = "1")]
    pub current_owner_id: ::prost::alloc::string::String,
    #[prost(enumeration = "ItemConditionProto", tag = "2")]
    pub current_condition: i32,
    #[prost(bool, tag = "3")]
    pub is_soulbound: bool,
    #[prost(enumeration = "MarketStatusProto", tag = "4")]
    pub market_status: i32,
    /// Price in NTC wei if listed
    #[prost(uint64, tag = "5")]
    pub market_price_ntc: u64,
    /// Unix timestamp
    #[prost(int64, tag = "6")]
    pub last_updated_timestamp: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BalancesProto {
    /// Validated: <= 1000000000 (MAX_XP)
    #[prost(uint64, tag = "1")]
    pub xp: u64,
    /// In wei, validated: <= MAX_SUPPLY
    #[prost(uint64, tag = "2")]
    pub ntc_balance: u64,
    /// Fiat credits for purchases, active in MVE
    #[prost(uint64, tag = "3")]
    pub credits_balance: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CryptoAddressesProto {
    /// Ethereum address for L3 chain
    #[prost(string, tag = "1")]
    pub l3_wallet_address: ::prost::alloc::string::String,
    /// Arbitrum One address
    #[prost(string, tag = "2")]
    pub l2_wallet_address: ::prost::alloc::string::String,
    /// Ethereum mainnet address
    #[prost(string, tag = "3")]
    pub l1_wallet_address: ::prost::alloc::string::String,
    /// Unix timestamp
    #[prost(int64, tag = "4")]
    pub addresses_updated_timestamp: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NtcStakingDetailsProto {
    /// Amount staked in wei
    #[prost(uint64, tag = "1")]
    pub total_staked_ntc: u64,
    /// Accumulated rewards in wei
    #[prost(uint64, tag = "2")]
    pub rewards_earned_ntc: u64,
    /// Unix timestamp
    #[prost(int64, tag = "3")]
    pub stake_start_timestamp: i64,
    /// Unix timestamp
    #[prost(int64, tag = "4")]
    pub last_reward_claim_timestamp: i64,
    /// 1-10 based on stake amount
    #[prost(uint32, tag = "5")]
    pub staking_tier: u32,
    /// Auto-reinvest rewards
    #[prost(bool, tag = "6")]
    pub auto_compound: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActiveBunkerguardDataProto {
    /// Linked BunkerguardRobot NFT ID (UUID)
    #[prost(string, optional, tag = "1")]
    pub robot_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Range: 1-100
    #[prost(uint32, tag = "2")]
    pub level: u32,
    #[prost(enumeration = "BunkerClassProto", optional, tag = "3")]
    pub current_class: ::core::option::Option<i32>,
    #[prost(enumeration = "ClassAffiliationProto", tag = "4")]
    pub current_affiliation: i32,
    /// Stats after equipment bonuses
    #[prost(message, optional, tag = "5")]
    pub final_stats: ::core::option::Option<CoreStatsProto>,
    /// slot_name -> nft_id mapping
    #[prost(map = "string, string", tag = "6")]
    pub equipped_items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Total XP earned by this robot
    #[prost(uint64, tag = "7")]
    pub total_xp: u64,
    /// Unix timestamp
    #[prost(int64, tag = "8")]
    pub last_active_timestamp: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentChainStateProto {
    /// Core fields - always active
    ///
    /// UUID v4, validated: ^\[0-9a-f\]{8}-\[0-9a-f\]{4}-\[0-9a-f\]{4}-\[0-9a-f\]{4}-\[0-9a-f\]{12}$
    #[prost(string, tag = "1")]
    pub player_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub balances: ::core::option::Option<BalancesProto>,
    #[prost(message, optional, tag = "3")]
    pub active_bunkerguard: ::core::option::Option<ActiveBunkerguardDataProto>,
    /// key: ItemTypeProto name, value: comma-separated NFT IDs
    #[prost(map = "string, string", tag = "4")]
    pub owned_nft_ids_by_type: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// On-chain fields - active in MVE on L3
    ///
    /// Active on L3 chain
    #[prost(message, optional, tag = "5")]
    pub ntc_staking: ::core::option::Option<NtcStakingDetailsProto>,
    /// Player's L3 wallet addresses
    #[prost(message, optional, tag = "6")]
    pub crypto_addresses: ::core::option::Option<CryptoAddressesProto>,
    /// Metadata
    ///
    /// Starting at 1, for migration handling
    #[prost(uint32, tag = "7")]
    pub schema_version: u32,
    /// Unix timestamp, validated: > 1609459200 (2021+)
    #[prost(int64, tag = "8")]
    pub last_updated_timestamp: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorResponseProto {
    #[prost(enumeration = "ErrorCodeProto", tag = "1")]
    pub code: i32,
    /// User-safe message, max 256 chars
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// For debugging, links to logs
    #[prost(string, tag = "3")]
    pub trace_id: ::prost::alloc::string::String,
    /// Additional context for debugging
    #[prost(map = "string, string", tag = "4")]
    pub details: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionRequestProto {
    /// Serialized transaction payload
    #[prost(string, tag = "1")]
    pub transaction_data: ::prost::alloc::string::String,
    /// 65-byte signature (hex encoded)
    #[prost(string, tag = "2")]
    pub signature: ::prost::alloc::string::String,
    /// Sender's L3 wallet address
    #[prost(string, tag = "3")]
    pub from_address: ::prost::alloc::string::String,
    /// Gas limit for transaction
    #[prost(uint64, tag = "4")]
    pub gas_limit: u64,
    /// Gas price in wei
    #[prost(uint64, tag = "5")]
    pub gas_price: u64,
    /// Transaction nonce
    #[prost(uint64, tag = "6")]
    pub nonce: u64,
    /// For request tracing
    #[prost(string, tag = "7")]
    pub trace_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionReceiptProto {
    /// L3 transaction hash
    #[prost(string, tag = "1")]
    pub transaction_hash: ::prost::alloc::string::String,
    #[prost(enumeration = "TransactionStatusProto", tag = "2")]
    pub status: i32,
    /// Block where transaction was mined
    #[prost(uint64, tag = "3")]
    pub block_number: u64,
    /// Actual gas used
    #[prost(uint64, tag = "4")]
    pub gas_used: u64,
    /// Error details if failed
    #[prost(string, tag = "5")]
    pub error_message: ::prost::alloc::string::String,
    /// Event logs from transaction
    #[prost(string, repeated, tag = "6")]
    pub emitted_events: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Unix timestamp
    #[prost(int64, tag = "7")]
    pub confirmation_timestamp: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PaginationProto {
    /// 1-based page number
    #[prost(uint32, tag = "1")]
    pub page: u32,
    /// Items per page, max 100
    #[prost(uint32, tag = "2")]
    pub page_size: u32,
    /// Total items available
    #[prost(uint64, tag = "3")]
    pub total_items: u64,
    /// Total pages available
    #[prost(uint32, tag = "4")]
    pub total_pages: u32,
}
