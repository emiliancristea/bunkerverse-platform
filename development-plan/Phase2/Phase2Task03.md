Task 2.3: Global Indexing Layer (Rust) - Functional Secure L3 Event Ingestion & Live Basic Indexing
(Full Schema P2 Defaults from L3 Smart Contracts - Principles G, J, K, N, O, R)
Technical Reference
ethers-rs or similar L3 client library documentation (for event subscription)
redis-rs crate documentation (for checkpointing)
Elasticsearch/Typesense Rust client documentation
Finalized v0.1 Protobuf Schemas
Context/Problem Statement
The Indexer service from Phase 1 returns static, hardcoded data. To make the BUNKERVERSE a dynamic and responsive world, we must replace this stubbed logic with a live data pipeline. This task involves fully implementing the Indexer's data ingestion pipeline, which will securely subscribe to and consume the detailed events now being emitted by our functional L3 smart contracts. It will then transform these events into structured documents and write them to the Indexer Backend (Elasticsearch/Typesense), creating the initial functional indexes for player accounts, NFTs, and token balances.
Measurable Objectives
A functional and secure data ingestion pipeline from the L3 Testnet to the Indexer Backend is implemented.
The pipeline can reliably consume, transform, and index all P2-scope events emitted by the L3 smart contracts.
A resilient checkpointing mechanism using Redis is functional, ensuring no events are missed or reprocessed on restart.
The entire pipeline is validated through end-to-end integration tests.
Implementation Guidance
Action: Fully implement the data ingestion pipeline in the Rust Indexer (/indexer/src/ingestion/). This pipeline will securely consume the detailed events now being generated by the functional L3 Smart Contracts (from Tasks 2.1 & 2.2). It will transform these events into structured documents and write them to the chosen Indexer Backend, building the initial functional indexes for player accounts, NFTs, and token balances. This replaces the hardcoded stubs from Phase 1 with a live data pipeline.
L3 Event Subscriber (/indexer/src/ingestion/l3_event_subscriber.rs - Secure & Functional for Full Schema P2 Events):
Implement a robust event-streaming client using a library like ethers-rs to call the eth_subscribe RPC method on the configured Arbitrum Orbit L3 node. The Indexer will be configured with the L3 node's RPC endpoint and the addresses of the core smart contracts to monitor for events.
Secure Communication (Principle R): The client must be configured to use a secure WebSocket (WSS) or HTTPS connection to the L3 node.
Deserialization & Validation:
The subscriber loop will receive Log messages from the stream.
It will parse the event topic and data to deserialize it into the correct CanonicalEventProto.
As a defense-in-depth measure, it will perform a basic structural validation on the deserialized event before passing it to the transformation layer.
Reliable Checkpointing: Implement a reliable checkpointing mechanism to track the last successfully processed block number.
Use Redis (via redis-rs) with a secure connection. The key could be indexer_checkpoint:l3.
After a batch of events is successfully written to the Indexer Backend, the subscriber task will update the checkpoint in Redis with the block number of the last event in the batch.
On startup or reconnection, the subscriber task will read its checkpoint from Redis and query the L3 for all relevant events starting from the next block, ensuring no events are missed or re-processed.
Indexable Data Transformer (/indexer/src/ingestion/event_transformer.rs - Functional for P2 Events & Full Schema P2 Defaults):
This module receives a CanonicalEventProto and transforms it into one or more documents. Implement transformation logic for each P2-scope event:
Player Account Index (player_index - document ID is player_id):
UserRegistered: Creates a new player document. Populates player_id, zkLogin_info, and the full default ActiveBunkerguardDataProto. Initializes xp_balance, ntc_balance, credits_balance to 0.
CreditsUpdated/XpMinted/XpBurned: Fetches the existing player document, updates the relevant balance field using safe math, and re-indexes the document.
RobotLinked: Updates player_doc.active_bunkerguard_data.robot_id_opt.
... and so on for all other P2 events (RobotUnlinked, RobotLevelledUp, etc.), updating the player document as specified in the original plan.
NFT Index (nft_index - document ID is nft_id):
NftMinted: Creates a new NFT document. The document must store: nft_id, current_owner_id, the full NftDetailsProto from the event payload, Initial current_condition, Initial market_status.
NftTransferred: Fetches the existing NFT document, updates the current_owner_id, and re-indexes it.
NftMarketStatusUpdated: Fetches the NFT document, updates the market_status field, and re-indexes it.
Transaction Log Index & Social Connection Index: Ingest SocialConnectionAdded and TradeExecutedRecordAdded events from the L3 Smart Contracts to populate these indexes.
Index Writer (/indexer/src/ingestion/index_writer.rs - Secure & Functional):
Implement a robust batch writing mechanism to the chosen Indexer Backend.
The Indexer will use the secure Rust client for the Indexer Backend (e.g., elasticsearch::Elasticsearch with TLS and API key/user auth) to perform bulk indexing operations.
The implementation must handle errors from the Indexer Backend and implement a suitable retry strategy (with exponential backoff). If retries fail, the batch should be logged to a dead-letter queue.
Threat Model Update & Secure Code Review (Principle R):
o Review and update the threat model for the Indexer (ADR-002).
o Specific Threats to Address:
Data Poisoning via L3 Stream: An attacker finds an exploit in the L3 smart contracts and emits malicious/invalid events. Mitigation: The primary defense is the L3 smart contracts' own security. The Indexer's defense-in-depth validation provides a second layer of detection.
Denial of Service: A flood of L3 events overwhelms the Indexer. Mitigation: The Indexer must be horizontally scalable. Its ingestion pipeline should use bounded channels to apply backpressure.
Inconsistent State: A failure in the Indexer's checkpointing or writing logic leads to a state that's out of sync with the L3. Mitigation: Robust checkpointing, dead-letter queues for failed batches, and a documented procedure for re-indexing.
o All new Rust Indexer code for the ingestion pipeline must undergo a security-focused peer review.
Testing (Rust):
o Unit Tests:
Test the event_transformer logic for every P2 L3 event.
Test the checkpointing logic with a mock Redis client.
Test the Index Writer's batching and retry logic with a mock Indexer Backend client.
o Integration Tests (Rust - L3 -> Indexer Backend - Live P2 Data):
Set up a local test environment with a functional local Arbitrum Orbit node, a live instance of the Indexer Backend (e.g., Elasticsearch in Docker), and the Rust Indexer service.
Use the Admin CLI to submit a sequence of P2-scope transactions to the L3 Smart Contracts.
Verification:
Verify the Rust Indexer's L3EventSubscriber securely consumes these events from the local L3 node.
Verify the checkpointing mechanism in Redis is updating correctly.
Query the Indexer Backend directly (using its native API) and assert that the corresponding documents are created/updated correctly with all specified P2 default details.
Update docs/progress_logs/progress_phase_2.md:
o Log the implementation of the functional and secure L3 event subscriber, the full transformer logic, and the robust index writer.
o Detail the index schemas/mappings for the Player and NFT documents.
o Document the checkpointing strategy using Redis.
o Document the threat model updates and security code review outcomes for the live Indexer pipeline.
o Document adherence to First Principles G, J, K, N, O, R.
Design Rationale
The Indexer is the critical "read layer" that enables a responsive and feature-rich user experience by offloading complex queries from the on-chain environment. A reliable, resilient, and real-time ingestion pipeline is the heart of this system. Using a robust checkpointing mechanism is non-negotiable for data integrity, ensuring the Indexer can recover from failures without losing its place in the on-chain history.
Operational Considerations
Local-First: The entire L3 -> Indexer -> Elasticsearch pipeline will run within the docker-compose.yml environment, providing a high-fidelity local testing setup.
Cloud-Ready: The Indexer is a stateless service (with checkpoint state in Redis) and is fully containerized, making it trivial to scale horizontally in a production Kubernetes environment. It will connect to a managed Elasticsearch/OpenSearch service and a managed Redis (ElastiCache) instance.
Verification & Validation Criteria
All unit and integration tests pass.
A successful end-to-end data flow is demonstrated from P2 L3 smart contract events to the creation/update of documents with all P2 default attributes in the live Indexer Backend.
The checkpointing mechanism is functional and correctly resumes ingestion after a simulated service restart.
Testing Methodologies
A combination of unit tests with mocked dependencies and a full end-to-end integration test running the L3 node, Indexer, and its database dependencies together in the local Docker Compose simulation.
Version Control Strategy
Branching: The Indexer's live ingestion pipeline is developed on a feature/indexer-live-ingestion branch.
Commits: The Git Commit message for this task will be exactly as specified.
Security Audit & Compliance Checkpoints
The Security Lead must review the defense-in-depth validation logic in the event transformer.
The security of the connection between the Indexer and the L3 node (authenticated RPC) and the Indexer and its databases (TLS) is a mandatory checkpoint.
The threat model for the Indexer must be updated to account for its new role as a live data consumer.
ReviewedBy: Indexer Lead, L3 Smart Contracts Lead, Rust Backend Lead, Security Lead.
ReviewOutcome: Approved.
ValidationMethod: All unit and integration tests pass. A successful end-to-end data flow is demonstrated. Checkpointing is functional.
Git Commit here: @https://github.com/emiliancristea/bunkerverse-platform.git "Phase 2.3: Implemented Rust Indexer Functional Secure L3 Event Ingestion & Live Basic Indexing (Full Schema P2 Defaults from L3)." @Phase2/