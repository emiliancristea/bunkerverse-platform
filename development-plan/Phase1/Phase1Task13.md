Task 1.13: Integration Testing (Full Loop)
(Secure zkLogin, Functional Services with Stubs, CC HOMESCREEN with Full Schema Default Data, NAR FFI Basic Functional Secure Inference Call - Principles O, R)
Technical Reference
All Phase 1 Test Plans
docker-compose.yml for the full MVE stack
bunkerverse-admin-cli tool (from Task 1.12)
The live L3 Testnet block explorer
Context/Problem Statement
All individual components for Phase 1 have been developed and unit-tested. However, their true functionality and security can only be validated by testing them as a complete, interconnected system. This task is the final, comprehensive integration test for the entire Phase 1 user flow. It validates the secure and functional interaction of all newly developed components, from the client-facing zkLogin process to the on-chain transaction submission and subsequent data display, ensuring the foundational plumbing of the MVE is robust and correct.
Measurable Objectives
The complete backend stack can be successfully launched via a single docker-compose up command.
An automated backend integration test successfully orchestrates the full zkLogin-to-data-fetch flow.
A manual or scripted E2E test of the Control Center Client successfully validates the full user journey from login to data display and a basic NAR call.
A suite of basic negative security tests passes, validating the robustness of the API and FFI boundaries.
Implementation Guidance
Action: Conduct comprehensive integration tests for the complete Phase 1 user flow, validating the secure and functional interaction of all newly developed components. This includes the full zkLogin process, data fetching through functional services with stubs, display of full-schema default data in the client, and a basic, secure, functional call to the NAR library. Basic negative security tests will also be performed.
Test Environment Setup (Docker Compose):
A docker-compose.yml file that starts:
Functional Rust Identity Service (P1.1) connected to a test MySQL DB.
Functional Rust L3 Transaction Submission Service (P1.3).
The simulated Arbitrum Orbit L3 Testnet sequencer network (along with its L2 and L1 dev nodes).
Functional Rust Indexer Service (P1.4 - API stubs returning full schema default data).
Functional Rust Player Account Service (P1.5) connected to a test Redis DB.
Functional Rust AI Data Service (P1.6).
All services configured for MVE (enable_crypto: false).
Backend Integration Test Scenario (Automated Rust Test):
o An automated Rust integration test will orchestrate the following backend flow:
Call the Identity Service to initiate zkLogin.
Simulate the OAuth callback and call ProcessZkProofAndGetSession.
Verify the Identity Service submits a UserRegistered event (with the full default ActiveBunkerguardDataProto) to the L3 Transaction Submission Service.
Verify the L3 Transaction Submission Service accepts the event and successfully submits the transaction to the L3 sequencer.
Use the JWT received from the Identity Service to call the Account Service's GetPlayerProfile.
Verify the Account Service securely calls the Indexer's stub and returns the correct full-schema default data.
Control Center Client E2E Test Scenario (Manual with a detailed script):
o Launch the compiled C++ Control Center Client.
o zkLogin: Successfully complete the secure zkLogin flow using a test account.
o HOMESCREEN Data: Verify the HOMESCREEN loads and displays the full-schema default player data (Level 1, Unclassed, Neutral, 12x sub-stats at 10) by fetching it through the entire chain (Client Rust Logic -> Account Service -> Indexer Stub).
o NAR Call: Via a debug button in the UI, trigger the rustBackend.generate_local_narrative function with a simple, sanitized prompt.
o NAR Verification: Verify that a placeholder narrative generated by the actual llama.cpp engine (via the secure Rust NAR FFI) is correctly received and displayed in the client UI.
o Data Persistence Check: After the test, use the L3 Testnet's block explorer to find the UserRegistered transaction for the test user and confirm it was correctly processed and included in a block.
Basic Negative Security Tests:
API Auth: In an automated test, try to call an authenticated endpoint (e.g., Account Service's GetPlayerProfile) with a missing or invalid JWT. Verify it returns UNAUTHENTICATED.
FFI Robustness: In a client-side unit test, call the Rust NAR FFI consumer with a null prompt. Verify it handles the error gracefully and doesn't crash the client.
Transaction Validation: Use the Admin CLI to try and submit a UserRegistered event with an invalid payload (e.g., a sub-stat with a value of 1000). Verify the L3 Transaction Submission Service rejects it with an INVALID_ARGUMENT error.
Update docs/progress_logs/progress_phase_1.md:
Document the setup of the comprehensive P1 integration test environment.
Detail the steps and validation checks for the backend and E2E test scenarios.
Log the successful outcomes, providing evidence of the L3 sequencer receiving the UserRegisteredProto transaction, the Indexer stubs being called securely, and the successful basic secure inference from the Rust NAR FFI being displayed in the client.
Detail the specific negative security tests performed and their expected (and observed) outcomes.
Design Rationale
This final, comprehensive integration test is the ultimate validation gate for Phase 1. It moves beyond testing individual components with mocks and validates the behavior of the entire, interconnected system as it will run in the local development environment. Passing these tests provides high confidence that our foundational architecture is stable, secure, and ready to be built upon.
Operational Considerations
The Docker Compose environment and the associated E2E test suites created in this task will become a cornerstone of our regression testing strategy. They will be run in CI on every major change to ensure that new features do not break the core user authentication and data display loop.
Verification & Validation Criteria
All defined Phase 1 integration tests pass successfully in the CI environment.
The end-to-end flow for user registration and initial data display is functional and secure for the P1 scope.
The foundational plumbing for the L3, Indexer (stubs), and NAR is proven to be correctly integrated and working as a cohesive system.
Testing Methodologies
A combination of automated Rust integration tests for the backend flow and scripted manual (or future automated UI) tests for the full client E2E scenario.
Version Control Strategy
Branching: The integration test suite is developed on a feature/p1-integration-tests branch.
Commits: The Git Commit message for this task will be exactly as specified.
Security Audit & Compliance Checkpoints
The Security Lead must review the results of the basic negative security tests to confirm that the API and FFI boundaries are behaving as expected under adversarial conditions. This is the final security sign-off for Phase 1's implementation.
ReviewedBy: QA Lead, All Tech Leads, Security Lead, Lead Architect.
ReviewOutcome: Approved.
ValidationMethod: All defined Phase 1 integration tests pass successfully. The end-to-end flow for user registration and initial data display is functional and secure for P1 scope.
Git Commit here: @https://github.com/emiliancristea/bunkerverse-platform.git "Phase 1.13: Comprehensive Integration Tests for Phase 1 Flow (Secure zkLogin, Services with Stubs, HOMESCREEN Full Schema Defaults, NAR FFI Basic Secure Functional Inference)." @Phase1/
Phase 1 Deliverable
(Security-Hardened Process-Hardened Foundation with Initial Functional Components, Full Schema Support for MVE, and Basic Functional Secure Local AI - Incorporating V2.4 BUNKERVERSE Overview)
Description
Upon completion of Phase 1, the project will have a set of foundational, security-hardened, and functionally integrated components that establish the core identity, on-chain foundation, and local AI capabilities of the BUNKERVERSE MVE. All development will have adhered to the established First Principles and will be meticulously documented. All components are built using the P0-validated technology stack (Arbitrum Orbit, Rust/Axum services, Client with Rust/CXX-Qt/QML, etc.) and are architected for the dual-mode strategy, with the MVE operating in its initial Mode.
1. Functional & Secure User Identity System (zkLogin)
Description: A fully functional and security-hardened Rust Identity Service is implemented and operational. It handles the complete server-side zkLogin flow for multiple OAuth providers. The system includes secure management of OAuth client secrets, robust CSRF protection, replay protection (ID token nonce validation), and secure, per-user cryptographic salt management. While full cryptographic ZKP verification is mocked for P1 (as a documented security TODO), the entire surrounding flow is secure and complete.
The Control Center Client (Rust Application Logic with CXX-Qt/QML UI) provides a complete and secure zkLogin user experience. It correctly orchestrates the OAuth flow using an external browser, securely communicates with the Rust Identity Service via gRPC, and upon success, receives and securely stores a platform session JWT using the native OS keychain/credential manager (via the keyring crate).
Acceptance Criteria: A user can launch the client, select an OAuth provider, complete the login flow via their browser, and be successfully authenticated within the client, resulting in a securely stored, persistent session. The entire flow is validated by end-to-end integration tests.
2. Functional BUNKERVERSE Netchain L3 Foundation
Description: The foundational layers of the BUNKERVERSE Netchain (Arbitrum Orbit L3) are deployed and functional as a public testnet.
L3 Testnet: A live Arbitrum Orbit L3 is running, settling to the Arbitrum Sepolia testnet (L2), and operated by a centralized sequencer. It has a public block explorer and RPC endpoint. Core L3 Smart Contract stubs are deployed and are interactable.
Transaction Submission Service: A functional gRPC service provides a secure entry point to the L3. It performs rigorous, stateless validation on all incoming transactions against the full MVE schemas before signing and submitting them to the L3 sequencer.
Acceptance Criteria: The Rust Identity Service can successfully submit a full-schema UserRegistered transaction to the L3 sequencer via the Submission Service. The transaction is successfully included in a block on the L3 testnet, verifiable via the block explorer. This full data flow is validated by automated integration tests.
3. Functional (Stubbed) Rust Indexer & Platform Services
Description: The Rust Decentralized Global Indexing Layer service provides functional gRPC API stubs. These stubs perform strict input validation and return hardcoded, but schema-valid, default data that fully reflects the rich MVE schemas for a new player.
The Rust Player Account Service and Rust Server-Side AI Data Service are functional. They securely interact with other services (Identity Service for JWT auth, Indexer for data fetching) via gRPC and correctly implement their respective P1 logic (e.g., profile aggregation with caching, AI context provisioning).
Acceptance Criteria: Authenticated calls from the client's Rust app logic to the Account and AI Data services succeed, which in turn successfully call the Indexer stubs and return the expected, full-schema default data.
4. Functional & Secure Local AI Runtime (Rust NAR with llama.cpp)
Description: The Rust Netchain AI Runtime (NAR) library is implemented and functional. It successfully wraps the llama.cpp library via a secure Rust FFI. It can load a manually placed (but checksum-verified) Gemma3 1B GGUF model. It exposes a secure C-FFI to the Control Center Client's Rust application logic, providing basic, functional, and secure inference.
Security: The FFI boundary is hardened with mandatory input validation, strict memory management contracts, and panic safety (catch_unwind) to prevent crashes.
Acceptance Criteria: The Control Center Client can successfully call the NAR FFI, trigger a basic inference on the loaded Gemma3 model, receive a generated text response, and handle memory/errors correctly, as validated by integration tests.
5. Functional Control Center Client Core (UI, Logic, Integration)
Description: The Control Center Client's HOMESCREEN, built with QML, successfully displays the (default/hardcoded from Indexer stubs, but fully structured) user profile data after a successful zkLogin. All data is fetched via the client's Rust Application Logic, which makes secure, authenticated gRPC calls to the backend services. The client can trigger and receive basic functional inference results from the local Rust NAR FFI securely. All other Control Center subpages exist as schema-aware, navigable placeholders. The core communication bridges (C++ Shell <-> Rust App Logic <-> QML UI) are finalized and robust for P1 scope.
Acceptance Criteria: The E2E integration test (P1.13) passes, demonstrating the full loop from user login to data display and a basic NAR call.
6. Comprehensive Documentation, Testing, and Process Adherence
Description: All Phase 1 development adheres strictly to the 18 "First Principles." All code has been peer-reviewed with a focus on security. The docs/progress_logs/progress_phase_1.md log provides a complete, detailed, and reviewed audit trail for all Phase 1 activities, security measures, and decisions. A comprehensive suite of automated unit and integration tests validates the functionality and security of all newly implemented components and their interactions within the P1 scope.
Acceptance Criteria: All defined P1 unit and integration tests pass in CI. The Phase 1 progress log is complete and signed off.
In summary, Phase 1 delivers a robust and secure foundation for the BUNKERVERSE MVE. The core identity system is functional and secure, with its on-chain component proven on a live L3 Testnet. The foundational plumbing for the Indexer and other services is functional, supporting the full MVE data schemas. The local AI runtime is integrated and working securely. The client provides a functional authentication and initial data display loop. The project is now ready to build the core L3 smart contract logic and live indexing upon this solid foundation in Phase 2.